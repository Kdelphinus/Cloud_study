# Going Further with Kubernetes(Section 25 - 33)

## Section 25: Requests and Limits

### Resource Requests

- 포드를 정의할 때 명시할 수 있다.
- 뭘 요청하냐에 따라 메모리 요청이나 CPU 요청이 될 수 있다.
- 만약 우리가 만든 큐에서 특정 이상의 메모리가 필요하다고 하면 우리는 yaml 파일에서 컨테이너 블록 안에 필요한 사양을 명시할 것이다.

```yaml
...
  template: # template for the pods
    metadata:
      labels:
        app: queue
    spec:
      containers:
      - name: queue
        image: richardchesterwood/k8s-fleetman-queue:release2
        resources:
          requests:
            memory: 300M  # 1Mi = 1024ki, 1ki = 1024 bytes
```

- 이렇게 요청을 적는 것은 권장되는데 이는 노드에 포드를 배치할 때 유용하기 때문이다.
- 이를 통해 1기가 메모리를 가진 노드에는 300메가 메모리가 필요한 포드를 3개만 배치하게 된다.
- 만약 이를 명시하지 않으면 노드에 포드 4개를 배치하려 할 것이고 이는 다른 3개의 포드에도 영향을 주게 된다.

- 노드의 사양을 알아보기 위해 다음과 같은 명령어를 사용한다.

```Shell
# 동작하는 kubernetes 노드 이름 확인
$ kubectl get nodes
```

```Shell
# 노드 사양 출력
$ kubectl describe node {node name}
...
Capacity:  # kubernetes에 할당된 사영
  cpu:                8  # 8개의 cpu 사용 가능
  ephemeral-storage:  61202244Ki
  hugepages-2Mi:      0
  memory:             8028408Ki  # 약 7.6 Gi
  pods:               110
Allocatable:  # 포드에 할당할 수 있는 사양
  cpu:                8
  ephemeral-storage:  56403987978
  hugepages-2Mi:      0
  memory:             7926008Ki
  pods:               110
...
```

- 그러먄 위처럼 `Capacity` 와 `Allocatable` 블록을 확인할 수 있다.
- `Capacity` 는 쿠버네티스에 할당된 사양이고 `Allocatable` 은 실제 포드에 할당할 수 있는 사양이다.
- 이를 토대로 메모리에 3000Mi를 요청하고 메모리가 감당할 수 있는 메모리를 넘어섰을 때 반응을 살펴볼 것이다.

```Shell
$ kubectl apply -f resource-testing.yaml
```

- 배포된 것을 확인할 수 있다.
- 하나가 배포된 것을 확인했으니 yaml 파일에 `replicas` 항목을 2로 늘리고 실행한다.
- 그리고 노드 사양을 다시 출력하면 밑에 다음과 같은 출력을 확인할 수 있다.

```Shell
$ kubectl describe node docker-desktop
...
  Namespace                   Name                                      CPU Requests  CPU Limits  Memory Requests  Memory Limits  Age
  ---------                   ----                                      ------------  ----------  ---------------  -------------  ---
  default                     queue-678d47565-8zrxc                     0 (0%)        0 (0%)      3000Mi (38%)     0 (0%)         4m2s
  default                     queue-678d47565-z9fzv                     0 (0%)        0 (0%)      3000Mi (38%)     0 (0%)         23s
  kube-system                 coredns-76f75df574-jn6wn                  100m (1%)     0 (0%)      70Mi (0%)        170Mi (2%)     29d
  kube-system                 coredns-76f75df574-n9mhn                  100m (1%)     0 (0%)      70Mi (0%)        170Mi (2%)     29d
  kube-system                 etcd-docker-desktop                       100m (1%)     0 (0%)      100Mi (1%)       0 (0%)         29d
  kube-system                 kube-apiserver-docker-desktop             250m (3%)     0 (0%)      0 (0%)           0 (0%)         29d
  kube-system                 kube-controller-manager-docker-desktop    200m (2%)     0 (0%)      0 (0%)           0 (0%)         29d
  kube-system                 kube-proxy-2t2nw                          0 (0%)        0 (0%)      0 (0%)           0 (0%)         29d
  kube-system                 kube-scheduler-docker-desktop             100m (1%)     0 (0%)      0 (0%)           0 (0%)         29d
  kube-system                 storage-provisioner                       0 (0%)        0 (0%)      0 (0%)           0 (0%)         29d
  kube-system                 vpnkit-controller                         0 (0%)        0 (0%)      0 (0%)           0 (0%)         29d
...
```

- 위를 보면 큐 2개가 있고 두 컨테이너가 메모리를 많이 차지하고 있음을 알 수 있다.
- 여기서 조심해야 할 것은 컨테이너가 저만큼 메모리를 사용 중인 것이 아니라 저 메모리를 사용할 수 있도록 보장한 것이라는 것이다.
- 이제 3개를 배포하고 포드를 확인하면 다음과 같다.

```Shell
$ kubectl get all
NAME                        READY   STATUS    RESTARTS   AGE
pod/queue-678d47565-2mth8   0/1     Pending   0          2s
pod/queue-678d47565-8zrxc   1/1     Running   0          7m14s
pod/queue-678d47565-z9fzv   1/1     Running   0          3m35s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   29d

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/queue   2/3     3            2           7m14s

NAME                              DESIRED   CURRENT   READY   AGE
replicaset.apps/queue-678d47565   3         3         2       7m14s
```

- 하나가 Pending 된 것을 확인할 수 있다.
- Pending된 노드를 describe로 확인해보면 아래와 같이 메모리 부족으로 실패한 메시지를 볼 수 있다.

```Shell
...
Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  85s   default-scheduler  0/1 nodes are available: 1 Insufficient memory. preemption: 0/1 nodes are available: 1 No preemption victims found for incoming pod
```

- 이때 쿠버네티스는 메모리를 다 사용하게 된 것은 아니고 세 번째 포드를 제외한 두 개의 포드 메모리만 사용한다.
- 또한 이전 강의에서 사용했던 클러스터를 사용하면 클러스터가 적절히 메모리가 비어있는 다른 노드에 배포한다.

